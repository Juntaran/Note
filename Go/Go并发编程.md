---
title: Go并发编程
tags: Go,并发,Go并发编程实战
grammar_cjkRuby: true
---

*2017.5.1*

# 并发编程基础
## 串行程序与并行程序
串行程序是指只能被`顺序执行`的指令列表  
并行程序是指可以被`并发执行`的两个及以上的串行程序的综合体  
**并发程序与并行程序**
> 并发程序是指可以被同时发起执行的程序，并发程序代表了所有可以实现并发行为的程序  
> 并行程序是指可以在并行的硬件上执行的并发程序
----------


## 并发程序内部的交互
并发程序内部可以分为多个部分，每个部分都可以看作是一个串行程序  
多个串行程序可能会对共享的资源进行访问，也可能它们之间需要传递一些数据  
在这种情况下，我们需要协调它们的执行，这就涉及到了`同步`  
同步的作用是避免在并发访问共享资源时可能发生的冲突，以确保有条不紊地传递数据  
> 在同一时刻，某个资源应该只被一个程序占用  
传递数据是并发程序内部的另一种交互方式，也成为并发程序内部的`通信`  
实际上，内部通信的方式不仅仅有`同步`，也有`异步`方式对通信进行处理  
异步能够让数据不加延迟地发送给数据接收方，即使数据接收方没有做好准备，也不会造成发送方的等待  
数据会被临时存放在通信缓存中，通信缓存是一种数据结构，是一种可以同时被多个程序使用的特殊共享资源  

# 多进程编程
进程间通信的方式被称为IPC(Inter-Process Communication)
在Linux中，IPC可以分为三类：
1. 基于通信的IPC方法  
1.1 数据传送：`管道pipe`传送字节流，`消息队列message queue`传送结构化的消息对象  
1.2 共享内存：`共享内存shared memory`最快  
2. 基于信号的IPC方法
`信号signal`，唯一的一种异步IPC方法
3. 基于同步的IPC方法
`信号量semaphore`

**Go支持管道、信号、socket**

## 进程
进程process维护了应用程序运行时的内存地址空间、文件和设备的句柄以及线程  
进程也是操作系统进行资源分配的一个基本单位

    pid := os.Getpid()			// 获取进程ID
    ppid := os.Getppid() 		// 获取父进程ID

多个进程同时对一个资源进行访问，很可能相互干扰，这种干扰称为`竞态条件race condition`  
Go的并发变成模型更加成熟先进，目标在于大幅减少程序产生竞态条件的可能  
执行过程中不能中断的操作称为`原子操作atomic operation`，所有的系统调用都属于原子操作  
只能被串行化访问或执行的某个资源或某段代码称为`临界区critical section`  
保证只有一个进程或线程在临界区之内的做法称为`互斥mutex`  
实现互斥的方法必须确保排他原则，`sync包`包含了对互斥的支持  
___
*2017.5.4*
### socket通信
socket既可以提供网络中不同计算机多个应用程序之间的通信支持，也可以成为单计算机上多个应用程序之间的通信手段，但是使用socket接口的绝大多数情况都是为了在网络中通信  
socket通信是基于TCP/IP协议栈的  


每个socket都存在与一个通信域中，通信域决定了该socket的地址格式和通信范围

|通信域|含义|   地址格式  |   通信范围  |
| --- | --- | --- | --- |
|  AF_INET   |  IPv4域   |  IPv4地址(4字节)，端口号(2字节)   |  基于IPv4协议的任意两台计算机上的两个应用程序   |
|  AF_INET6   |  IPv6域   |  IPv6地址(16字节)，端口号(2字节)   | 基于IPv6协议的任意两台计算机上的两个应用程序    |
|  AF_UNIX   |  Unix域   |  路径名称   |  同一台计算机上的两个应用程序   |

AF是address family的缩写，意为地址域

socket有5种类型

|  特性   |  SOCK_DGRAM   |  SOCK_RAW   |  SOCK_SEQPACKET   |  SOCK_STREAM   |
| --- | --- | --- | --- | --- |
|  数据形式   |  数据报   |  数据报   |  字节流   |  字节流   |
|  数据边界   |  有   |  有   |  有   |  无   |
|  逻辑连接   |  无   |  无   |  有   |  有   |
|  数据有序性   |  无   |  无   |  有   |  有   |
|  传输可靠性   |  无   |  无   |  有   |  有   |

> 以`数据报`为数据形式意味着`接收方`的socket接口程序可以意识到数据的边界并会切分，  
> 这样省去了接收方的应用程序寻找数据边界和切分数据的工作量

> 以`字节流`为数据形式的传输实际上传输的是一个字节接着一个字节的串，类似于一个很长的字节数组  
> 一般情况下字节流不能体现那些字节属于哪个数据包，因此socket接口程序无法分离独立的数据包  
> 这一工作只能交给应用程序去完成  
> 但是`SOCK_SEQPACKET`类型的socket接口程序例外，  
> 发送方的socket接口程序会记录数据边界，边界信息也会随着字节流发送给接收方  
> 接收方的socket接口程序会根据边界切分字节流，还原成字节流片段并根据顺序传递给应用程序


在Go提供了socket的API，需要使用标准库中的net包

在服务端首先会用到这个函数

    func Listen(net, laddr string) (Listener, error)
    
函数net.Listen用于获取监听器，它接受两个string类型的参数  
第一个是参数的含义是以何种监听协议给定的地址，该参数必须为`面向流`的协议

| 字面量 |socket协议|备注|
| --- | --- | --- |
|tcp|TCP|无|
|tcp4|TCP|网际互联协议只支持IPv4|
|tcp6|TCP|网际互联协议只支持IPv6|
|udp|UDP|无|
|udp4|UDP|网际互联协议只支持IPv4|
|udp6|UDP|网际互联协议只支持IPv6|
|unix|有效|可看作通信域为AF_UNIX切类型为SOCK_STREAM时内核采用的默认协议|
|unixgram|有效|可看作通信域为AF_UNIX切类型为SOCK_DGRAM时内核采用的默认协议|
|unixpacket|有效|可看作通信域为AF_UNIX切类型为SOCK_SEQPACKET时内核采用的默认协议|

如上表所示，第一个参数必须是`tcp`、`tcp4`、`tcp6`、`unix`和`unixpacket`中的一个

第二个ladder表示当前程序在网络中的标识  
`laddr`是Local Address的缩写，格式为`host:port`  
`host`处内容必须是当前计算机对应的IP地址或主机名  
`port`则代表当前程序欲监听的端口号  

    listener, err := net.Listen("tcp", "127.0.0.1:8085")

监听函数Listen调用之后，当err为nil时，即可等待客户端的连接请求

    conn, err := listener.Accept()

调用监听器的Accept方法时，会进入阻塞状态，直到有客户端程序发起TCP连接


客户端使用net包的Dial函数用于向制定的网络地址发送连接建立请求

    func Dial(network, address string) (Conn, error)

Dial函数同样接收两个参数
第一个参数`network`与net.Listen函数的第一个参数`net`类似，但是有更多的选项  
除了net.Listen的第一个可选参数外，还可以使用`udp`、`udp4`、`udp6`、`ip`、`ip4`和`ip6`  
这是因为在发送数据前不一定要先建立连接，UDP协议和IP协议都是`面向无连接`的协议  

第二个参数`address`和net.Listen函数的第二个参数`laddr`完全一致  
它指定的是服务端的地址

    conn, err := net.Dial("tcp", "127.0.0.1:8085")

如果需要手动设置超时时间，可以使用DialTimeout函数（Dial函数默认timeout=75秒）

    func DialTimeout(network, address string, timeout time.Duration) (Conn, error)

DialTimeout函数的最后一个参数的单位是纳秒， 如果想设置2秒

    conn, err := net.DialTimeout("tcp", "127.0.0.1:8085", 2*time.Second)

服务端创建监听器并开始等待连接请求之后，一旦收到客户端的连接请求，服务端就和和客户端进行`三次握手`  
当成功建立连接后，无论服务端程序还是客户端程序都会获得一个`net.Conn`类型的值  
之后，两端便可以用该值交换数据了  
Go的socket编程API程序在底层获取的是一个`非阻塞式`的socket实例，  
这意味着在该实例之上的数据读取操作也都是非阻塞式的  
应用程序试图通过系统调用`read`从socket接收缓冲区中读取数据的时候，即使接收缓冲区没有任何数据，  
操作系统也不会使系统调用`read`进入`阻塞状态`，而是直接返回一个错误码为`EAGAIN`的错误  
应用程序不应该视此为一个真正的错误，应该`忽略`它，并稍等片刻再次读取  

同样，当socket发送缓冲区已满时，如果应用程序仍向发送缓冲区写入一段数据时，  
系统调用`write`也`不会阻塞`，而是直接返回一个错误码为`EAGAIN`的错误  
应用程序应该`忽略`该错误，并稍等片刻再次尝试写入数据  
如果发送缓冲区有少许剩余空间但不足以放入这段数据  
系统调用`wirte`会尽可能写入一部分数据，然后返回已经写入的字节的数据量  
这一特性成为`部分写(partial wirte)`，应用程序应该每次调用`write`之后都去检查该结果值  

除了`read`和`write`外，系统调用`accept`也会显现出一致的`非阻塞`风格  
它不会阻塞以等待新的连接到来，而会直接返回错误码为`EAGAIN`的错误  
但是Go的socket编程API在一定程度上帮助我们屏蔽了相关系统调用的EAGAIN错误，  
这使得有些socket编程API调用起来`像是阻塞式`的  
另外，Go的socket编程API同样`屏蔽`了非阻塞式socket接口的部分`写特性`  
相关API会直接把所有数据全部写入到socket发送缓冲区之后才返回，除非在写入的过程中发生了某种错误  
但是，它却`保留`了非阻塞式socket接口的部分`读特性`  
这样做是合理的，因为在TCP协议之上传输的数据是字节流形式的，  
数据接收方无法感知数据的边界（消息边界），因此API无法判断函数调用返回的时机  
把`数据切分`和`分批返回`的任务交给调用方程序即可，因此`部分读`需要我们在程序中做一些额外的处理  










---
title: Go并发编程
tags: Go,并发,Go并发编程实战
grammar_cjkRuby: true
---

*2017.5.1*

# 并发编程基础
## 串行程序与并行程序
串行程序是指只能被`顺序执行`的指令列表
并行程序是指可以被`并发执行`的两个及以上的串行程序的综合体
**并发程序与并行程序**
> 并发程序是指可以被同时发起执行的程序，并发程序代表了所有可以实现并发行为的程序
> 并行程序是指可以在并行的硬件上执行的并发程序
----------


## 并发程序内部的交互
并发程序内部可以分为多个部分，每个部分都可以看作是一个串行程序
多个串行程序可能会对共享的资源进行访问，也可能它们之间需要传递一些数据
在这种情况下，我们需要协调它们的执行，这就涉及到了`同步`
同步的作用是避免在并发访问共享资源时可能发生的冲突，以确保有条不紊地传递数据
> 在同一时刻，某个资源应该只被一个程序占用
传递数据是并发程序内部的另一种交互方式，也成为并发程序内部的`通信`
实际上，内部通信的方式不仅仅有`同步`，也有`异步`方式对通信进行处理
异步能够让数据不加延迟地发送给数据接收方，即使数据接收方没有做好准备，也不会造成发送方的等待
数据会被临时存放在通信缓存中，通信缓存是一种数据结构，是一种可以同时被多个程序使用的特殊共享资源

# 多进程编程
进程间通信的方式被称为IPC(Inter-Process Communication)
在Linux中，IPC可以分为三类：
1. 基于通信的IPC方法
1.1 数据传送：`管道pipe`传送字节流，`消息队列message queue`传送结构化的消息对象
1.2 共享内存：`共享内存shared memory`最快
2. 基于信号的IPC方法
`信号signal`，唯一的一种异步IPC方法
3. 基于同步的IPC方法
`信号量semaphore`

**Go支持管道、信号、socket**

## 进程
进程process维护了应用程序运行时的内存地址空间、文件和设备的句柄以及线程
进程也是操作系统进行资源分配的一个基本单位

    pid := os.Getpid()			// 获取进程ID
    ppid := os.Getppid() 		// 获取父进程ID

多个进程同时对一个资源进行访问，很可能相互干扰，这种干扰称为`竞态条件race condition`
Go的并发变成模型更加成熟先进，目标在于大幅减少程序产生竞态条件的可能
执行过程中不能中断的操作称为`=原子操作atomic operation`，所有的系统调用都属于原子操作
只能被串行化访问或执行的某个资源或某段代码称为`临界区critical section`
保证只有一个进程或线程在临界区之内的做法称为`互斥mutex`
实现互斥的方法必须确保排他原则，`sync包`包含了对互斥的支持


### socket通信
socket既可以提供网络中不同计算机多个应用程序之间的通信支持，也可以成为单计算机上多个应用程序之间的通信手段。但是使用socket接口的绝大多数情况都是为了在网络中通信
socket通信是基于TCP/IP协议栈的


每个socket都存在与一个通信域中，通信域决定了该socket的地址格式和通信范围

|通信域|含义|   地址格式  |   通信范围  |
| --- | --- | --- | --- |
|  AF_INET   |  IPv4域   |  IPv4地址(4字节)，端口号(2字节)   |  基于IPv4协议的任意两台计算机上的两个应用程序   |
|  AF_INET6   |  IPv6域   |  IPv6地址(16字节)，端口号(2字节)   | 基于IPv6协议的任意两台计算机上的两个应用程序    |
|  AF_UNIX   |  Unix域   |  路径名称   |  同一台计算机上的两个应用程序   |

AF是address family的缩写，意为地址域

socket有5种类型

|  特性   |  SOCK_DGRAM   |  SOCK_RAW   |  SOCK_SEQPACKET   |  SOCK_STREAM   |
| --- | --- | --- | --- | --- |
|  数据形式   |  数据报   |  数据报   |  字节流   |  字节流   |
|  数据边界   |  有   |  有   |  有   |  无   |
|  逻辑连接   |  无   |  无   |  有   |  有   |
|  数据有序性   |  无   |  无   |  有   |  有   |
|  传输可靠性   |  无   |  无   |  有   |  有   |

> 以`数据报`为数据形式意味着`接收方`的socket接口程序可以意识到数据的边界并会切分，
> 这样省去了接收方的应用程序寻找数据边界和切分数据的工作量

> 以`字节流`为数据形式的传输实际上传输的是一个字节接着一个字节的川，
> 类似于一个很长的字节数组
> 一般情况下字节流不能体现那些字节属于哪个数据包，因此socket接口程序无法分离独立的数据包
> 这一工作只能交给应用程序去完成
> 但是`SOCK_SEQPACKET`类型的socket接口程序例外，
> 发送方的socket接口程序会记录数据边界，边界信息也会随着字节流发送给接收方
> 接收方的socket接口程序会根据边界切分字节流，还原成字节流片段并根据顺序传递给应用程序


在Go提供了socket的API，需要使用标准库中的net包

首先会用到这个函数

    func Listen(net, laddr string) (Listener, error)
    
函数net.Listen用于获取监听器，它接受两个string类型的参数
第一个是何种监听协议给定的地址，该参数必须为`面向流`的协议
| 字面量 |socket协议|备注|
| --- | --- | --- |
|tcp|TCP|无|
|tcp4|TCP|网际互联协议只支持IPv4|
|tcp6|TCP|网际互联协议只支持IPv6|
|udp|UDP|无|
|udp4|UDP|网际互联协议只支持IPv4|
|udp6|UDP|网际互联协议只支持IPv6|
|unix|有效|可看作通信域为AF_UNIX切类型为SOCK_STREAM时内核采用的默认协议|
|unixgram|有效|可看作通信域为AF_UNIX切类型为SOCK_DGRAM时内核采用的默认协议|
|unixpacket|有效|可看作通信域为AF_UNIX切类型为SOCK_SEQPACKET时内核采用的默认协议|

第二个是









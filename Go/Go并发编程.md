---
title: Go并发编程
tags: Go,并发,Go并发编程实战
grammar_cjkRuby: true
---

*2017.5.1*

# 并发编程基础
## 串行程序与并行程序
串行程序是指只能被==顺序执行==的指令列表
并行程序是指可以被==并发执行==的两个及以上的串行程序的综合体
**并发程序与并行程序**
> 并发程序是指可以被同时发起执行的程序，并发程序代表了所有可以实现并发行为的程序
> 并行程序是指可以在并行的硬件上执行的并发程序
----------


## 并发程序内部的交互
并发程序内部可以分为多个部分，每个部分都可以看作是一个串行程序
多个串行程序可能会对共享的资源进行访问，也可能它们之间需要传递一些数据
在这种情况下，我们需要协调它们的执行，这就涉及到了==同步==
同步的作用是避免在并发访问共享资源时可能发生的冲突，以确保有条不紊地传递数据
> 在同一时刻，某个资源应该只被一个程序占用
传递数据是并发程序内部的另一种交互方式，也成为并发程序内部的==通信==
实际上，内部通信的方式不仅仅有==同步==，也有==异步==方式对通信进行处理
异步能够让数据不加延迟地发送给数据接收方，即使数据接收方没有做好准备，也不会造成发送方的等待
数据会被临时存放在通信缓存中，通信缓存是一种数据结构，是一种可以同时被多个程序使用的特殊共享资源

# 多进程编程
进程间通信的方式被称为IPC(Inter-Process Communication)
在Linux中，IPC可以分为三类：
1. 基于通信的IPC方法
1.1 数据传送：==管道pipe==传送字节流，==消息队列message queue==传送结构化的消息对象
1.2 共享内存：==共享内存shared memory==最快
2. 基于信号的IPC方法
==信号signal==，唯一的一种异步IPC方法
3. 基于同步的IPC方法
==信号量semaphore==

**Go支持管道、信号、socket**

## 进程
进程process维护了应用程序运行时的内存地址空间、文件和设备的句柄以及线程
进程也是操作系统进行资源分配的一个基本单位

    pid := os.Getpid()			// 获取进程ID
    ppid := os.Getppid() 		// 获取父进程ID

多个进程同时对一个资源进行访问，很可能相互干扰，这种干扰称为==竞态条件race condition==
Go的并发变成模型更加成熟先进，目标在于大幅减少程序产生竞态条件的可能
执行过程中不能中断的操作称为==原子操作atomic operation==，所有的系统调用都属于原子操作
只能被串行化访问或执行的某个资源或某段代码称为==临界区critical section==
保证只有一个进程或线程在临界区之内的做法称为==互斥mutex==
实现互斥的方法必须确保排他原则，==sync包==包含了对互斥的支持


### socket通信
socket既可以提供网络中不同计算机多个应用程序之间的通信支持，也可以成为单计算机上多个应用程序之间的通信手段。但是使用socket接口的绝大多数情况都是为了在网络中通信
socket通信是基于TCP/IP协议栈的
在Go提供了socket的API，需要使用标准库中的net包

| 字面量 |socket协议|备注|
| --- | --- | --- |
|tcp|TCP|无|
|tcp4|TCP|网际互联协议只支持IPv4|
|tcp6|TCP|网际互联协议只支持IPv6|
|udp|UDP|无|
|udp4|UDP|网际互联协议只支持IPv4|
|udp6|UDP|网际互联协议只支持IPv6|
|unix|有效|可看作通信域为AF_UNIX切类型为SOCK_STREAM时内核采用的默认协议|
|unixgram|有效|可看作通信域为AF_UNIX切类型为SOCK_DGRAM时内核采用的默认协议|
|unixpacket|有效|可看作通信域为AF_UNIX切类型为SOCK_SEQPACKET时内核采用的默认协议|










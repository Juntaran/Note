---
title: Go并发编程
tags: Go,并发,Go并发编程实战
grammar_cjkRuby: true
---

*2017.5.1*

# 并发编程基础
## 串行程序与并行程序
串行程序是指只能被`顺序执行`的指令列表  
并行程序是指可以被`并发执行`的两个及以上的串行程序的综合体  
**并发程序与并行程序**
> 并发程序是指可以被同时发起执行的程序，并发程序代表了所有可以实现并发行为的程序  
> 并行程序是指可以在并行的硬件上执行的并发程序
----------


## 并发程序内部的交互
并发程序内部可以分为多个部分，每个部分都可以看作是一个串行程序  
多个串行程序可能会对共享的资源进行访问，也可能它们之间需要传递一些数据  
在这种情况下，我们需要协调它们的执行，这就涉及到了`同步`  
同步的作用是避免在并发访问共享资源时可能发生的冲突，以确保有条不紊地传递数据  
> 在同一时刻，某个资源应该只被一个程序占用  
传递数据是并发程序内部的另一种交互方式，也成为并发程序内部的`通信`  
实际上，内部通信的方式不仅仅有`同步`，也有`异步`方式对通信进行处理  
异步能够让数据不加延迟地发送给数据接收方，即使数据接收方没有做好准备，也不会造成发送方的等待  
数据会被临时存放在通信缓存中，通信缓存是一种数据结构，是一种可以同时被多个程序使用的特殊共享资源  

# 多进程编程
进程间通信的方式被称为IPC(Inter-Process Communication)
在Linux中，IPC可以分为三类：
1. 基于通信的IPC方法  
1.1 数据传送：`管道pipe`传送字节流，`消息队列message queue`传送结构化的消息对象  
1.2 共享内存：`共享内存shared memory`最快  
2. 基于信号的IPC方法
`信号signal`，唯一的一种异步IPC方法
3. 基于同步的IPC方法
`信号量semaphore`

**Go支持管道、信号、socket**

## 进程
进程process维护了应用程序运行时的内存地址空间、文件和设备的句柄以及线程  
进程也是操作系统进行资源分配的一个基本单位

    pid := os.Getpid()			// 获取进程ID
    ppid := os.Getppid() 		// 获取父进程ID

多个进程同时对一个资源进行访问，很可能相互干扰，这种干扰称为`竞态条件race condition`  
Go的并发变成模型更加成熟先进，目标在于大幅减少程序产生竞态条件的可能  
执行过程中不能中断的操作称为`原子操作atomic operation`，所有的系统调用都属于原子操作  
只能被串行化访问或执行的某个资源或某段代码称为`临界区critical section`  
保证只有一个进程或线程在临界区之内的做法称为`互斥mutex`  
实现互斥的方法必须确保排他原则，`sync包`包含了对互斥的支持  
___
*2017.5.4*
### socket通信
socket既可以提供网络中不同计算机多个应用程序之间的通信支持，也可以成为单计算机上多个应用程序之间的通信手段，但是使用socket接口的绝大多数情况都是为了在网络中通信  
socket通信是基于TCP/IP协议栈的  

![socket](https://raw.githubusercontent.com/Juntaran/Note/master/pictures/socket.jpg)

![socket通信](https://raw.githubusercontent.com/Juntaran/Note/master/pictures/socketConn.jpg)


每个socket都存在与一个通信域中，通信域决定了该socket的地址格式和通信范围

|通信域|含义|   地址格式  |   通信范围  |
| --- | --- | --- | --- |
|  AF_INET   |  IPv4域   |  IPv4地址(4字节)，端口号(2字节)   |  基于IPv4协议的任意两台计算机上的两个应用程序   |
|  AF_INET6   |  IPv6域   |  IPv6地址(16字节)，端口号(2字节)   | 基于IPv6协议的任意两台计算机上的两个应用程序    |
|  AF_UNIX   |  Unix域   |  路径名称   |  同一台计算机上的两个应用程序   |

AF是address family的缩写，意为地址域

socket有5种类型

|  特性   |  SOCK_DGRAM   |  SOCK_RAW   |  SOCK_SEQPACKET   |  SOCK_STREAM   |
| --- | --- | --- | --- | --- |
|  数据形式   |  数据报   |  数据报   |  字节流   |  字节流   |
|  数据边界   |  有   |  有   |  有   |  无   |
|  逻辑连接   |  无   |  无   |  有   |  有   |
|  数据有序性   |  无   |  无   |  有   |  有   |
|  传输可靠性   |  无   |  无   |  有   |  有   |

> 以`数据报`为数据形式意味着`接收方`的socket接口程序可以意识到数据的边界并会切分，  
> 这样省去了接收方的应用程序寻找数据边界和切分数据的工作量

> 以`字节流`为数据形式的传输实际上传输的是一个字节接着一个字节的串，类似于一个很长的字节数组  
> 一般情况下字节流不能体现那些字节属于哪个数据包，因此socket接口程序无法分离独立的数据包  
> 这一工作只能交给应用程序去完成  
> 但是`SOCK_SEQPACKET`类型的socket接口程序例外，  
> 发送方的socket接口程序会记录数据边界，边界信息也会随着字节流发送给接收方  
> 接收方的socket接口程序会根据边界切分字节流，还原成字节流片段并根据顺序传递给应用程序


在Go提供了socket的API，需要使用标准库中的net包

在服务端首先会用到这个函数

    func Listen(net, laddr string) (Listener, error)
    
函数net.Listen用于获取监听器，它接受两个string类型的参数  
第一个是参数的含义是以何种监听协议给定的地址，该参数必须为`面向流`的协议

| 字面量 |socket协议|备注|
| --- | --- | --- |
|tcp|TCP|无|
|tcp4|TCP|网际互联协议只支持IPv4|
|tcp6|TCP|网际互联协议只支持IPv6|
|udp|UDP|无|
|udp4|UDP|网际互联协议只支持IPv4|
|udp6|UDP|网际互联协议只支持IPv6|
|unix|有效|可看作通信域为AF_UNIX切类型为SOCK_STREAM时内核采用的默认协议|
|unixgram|有效|可看作通信域为AF_UNIX切类型为SOCK_DGRAM时内核采用的默认协议|
|unixpacket|有效|可看作通信域为AF_UNIX切类型为SOCK_SEQPACKET时内核采用的默认协议|

如上表所示，第一个参数必须是`tcp`、`tcp4`、`tcp6`、`unix`和`unixpacket`中的一个

第二个ladder表示当前程序在网络中的标识  
`laddr`是Local Address的缩写，格式为`host:port`  
`host`处内容必须是当前计算机对应的IP地址或主机名  
`port`则代表当前程序欲监听的端口号  

    listener, err := net.Listen("tcp", "127.0.0.1:8085")

监听函数Listen调用之后，当err为nil时，即可等待客户端的连接请求

    conn, err := listener.Accept()

调用监听器的Accept方法时，会进入阻塞状态，直到有客户端程序发起TCP连接


客户端使用net包的Dial函数用于向制定的网络地址发送连接建立请求

    func Dial(network, address string) (Conn, error)

Dial函数同样接收两个参数
第一个参数`network`与net.Listen函数的第一个参数`net`类似，但是有更多的选项  
除了net.Listen的第一个可选参数外，还可以使用`udp`、`udp4`、`udp6`、`ip`、`ip4`和`ip6`  
这是因为在发送数据前不一定要先建立连接，UDP协议和IP协议都是`面向无连接`的协议  

第二个参数`address`和net.Listen函数的第二个参数`laddr`完全一致  
它指定的是服务端的地址

    conn, err := net.Dial("tcp", "127.0.0.1:8085")

如果需要手动设置超时时间，可以使用DialTimeout函数（Dial函数默认timeout=75秒）

    func DialTimeout(network, address string, timeout time.Duration) (Conn, error)

DialTimeout函数的最后一个参数的单位是纳秒， 如果想设置2秒

    conn, err := net.DialTimeout("tcp", "127.0.0.1:8085", 2*time.Second)

服务端创建监听器并开始等待连接请求之后，一旦收到客户端的连接请求，服务端就和和客户端进行`三次握手`  
当成功建立连接后，无论服务端程序还是客户端程序都会获得一个`net.Conn`类型的值  
之后，两端便可以用该值交换数据了  
Go的socket编程API程序在底层获取的是一个`非阻塞式`的socket实例，  
这意味着在该实例之上的数据读取操作也都是非阻塞式的  
应用程序试图通过系统调用`read`从socket接收缓冲区中读取数据的时候，即使接收缓冲区没有任何数据，  
操作系统也不会使系统调用`read`进入`阻塞状态`，而是直接返回一个错误码为`EAGAIN`的错误  
应用程序不应该视此为一个真正的错误，应该`忽略`它，并稍等片刻再次读取  

同样，当socket发送缓冲区已满时，如果应用程序仍向发送缓冲区写入一段数据时，  
系统调用`write`也`不会阻塞`，而是直接返回一个错误码为`EAGAIN`的错误  
应用程序应该`忽略`该错误，并稍等片刻再次尝试写入数据  
如果发送缓冲区有少许剩余空间但不足以放入这段数据  
系统调用`wirte`会尽可能写入一部分数据，然后返回已经写入的字节的数据量  
这一特性成为`部分写(partial wirte)`，应用程序应该每次调用`write`之后都去检查该结果值  

除了`read`和`write`外，系统调用`accept`也会显现出一致的`非阻塞`风格  
它不会阻塞以等待新的连接到来，而会直接返回错误码为`EAGAIN`的错误  
但是Go的socket编程API在一定程度上帮助我们屏蔽了相关系统调用的EAGAIN错误，  
这使得有些socket编程API调用起来`像是阻塞式`的  
另外，Go的socket编程API同样`屏蔽`了非阻塞式socket接口的部分`写特性`  
相关API会直接把所有数据全部写入到socket发送缓冲区之后才返回，除非在写入的过程中发生了某种错误  
但是，它却`保留`了非阻塞式socket接口的部分`读特性`  
这样做是合理的，因为在TCP协议之上传输的数据是字节流形式的，  
数据接收方无法感知数据的边界（消息边界），因此API无法判断函数调用返回的时机  
把`数据切分`和`分批返回`的任务交给调用方程序即可，因此`部分读`需要我们在程序中做一些额外的处理  


* **Read方法**

Read方法用于从socket的接收缓冲区中读取数据

    Read(b []byte) (n int, err error)
    
该方法接收一个`[]byte`类型的参数，相当于一个用来存放从连接上接收到的数据的容器  
Read方法会把它当作空的容器并试图填满，相应位置上的原元素会被替换  
为了避免混乱，尽量让这个容器在填充之前保持绝对干净  
也就是说，传递个Read方法的参数值应该是一个`不包含任何非零值元素的切片值`  

    b := make([]byte, 10)
    n, err := conn.Read(b)
    content := string(b[:n])

通过依据结果n对参数b做切片操作可以抽取出接收到的数据  
如果socket编程API在从socket的接收缓冲区中读取数据时发现TCP连接已经被另一端关闭了  
就会立刻返回一个error类型值，即`io.EOF`  
意味着此TCP连接之上在没有可以读取的数据

    var dataBuffer bytes.Buffer
    b := make([]byte, 10)
    for {
    	n, err := conn.Read(b)
        if err != nil {
        	if err == io.EOF {
            	fmt.Println("The connection is closed.")
                conn.Close()
            } else {
            	fmt.Printf("Read Error: %s\n", err)
            }
            break
        }
        dataBuffer.Write(b[:n])
    }

上述的例子是一种最简单的情况，我们一般不会`在连接关闭之前无休止地`从连接上读取数据  
作为一个处在TCP/IP协议栈应用层的程序，负责切分数据并生成有实际意义的消息  
即使在最简单的情况下，应用层程序也知道怎样在接收到的字节流上进行切分  
此外，还有一个更简便的方法：  
利用标准库代码包`bufio`中的API实现一些较为复杂的数据切分操作  
bufio是Buffered I/O的缩写，它提供了与带缓存的I/O操作有关的支持  
比如通过包装不带缓存的I/O类型值的方式增强它们的功能  
`bufio.NewReader`接收一个`io.Reader`类型的参数值  
net.Conn类型实现了io.Reader接口中唯一的方法Read，所以它是该接口的一个实现类型  
因此，可以使用bufio.NewReader函数包装变量conn  

    reader := bufio.NewReader(conn)
ReadBytes方法接收一个byte类型的参数值，该参数值是通信两端协商一致的消息边界  

    line, err := reader.ReadBytes('\n')
另外还有`bufio.NewScanner函数`、`bufio.Scanner类型及其方法`等

* **Write方法**  

Write方法用于向socket的发送缓冲区写入数据  

    Write(b []byte) (n int, err error)

net.Conn类型是一个io.Writer接口的实现类型，所以net.Conn类型的值可以作为bufio.NewWriter函数的参数值  

    writer := bufio.NewWriter(conn)

与reader类似，writer的值可以看作是针对变量conn代表的TCP连接的缓冲写入器  
可以通过调用其上的以`Writer为名称前缀`的方法来分批次地向其中的缓冲区写入数据  
也可以通过调用它

* **Close方法**
Close放方法会关闭连接，调用Close方法时，Read方法或Write方法正在被调用且还未执行结束，  
它们会立即执行结束并返回非nil的error值，即使它们处于阻塞状态  

* **LocalAddr和RemoteAddr方法**
顾名思义是获取当前通信的某一端在网络中的地址，返回一个net.Addr类型的结果  
方法集合中有两个方法：`Network`和`String`  
Network返回当前连接所使用的协议的名称`conn.LocalAddr().Network()`，得到`tcp`  
String方法根据通信域返回相应格式的地址`conn.RemoteAddr().String()`  

* **SetDeadline SetReadDeadline SetWriteDeadline方法**
它们只接收一个time.Time类型值作为参数，返回一个error类型值作为结果  
SetDeadline方法会设定在当前连接上的`I/O操作的超时时间`  
SetReadDeadline和SetWriteDeadline方法分别针对读和写的超时控制  



*2017.5.9*
 
# 多线程编程

多线程编程是一种比多进程编程更加灵活、高效的并发编程方式  

## 线程

线程可以视为·进程中的控制流，一个进程至少包含一个线程  
一个进程的第一个线程会随着这个进程的启动而创建，也就是主线程  
和进程一样，每个线程都有属于自己的ID——TID  
与进程不同，线程ID在系统范围内可以不唯一，只在其所属进程的范围里唯一  
但是Linux系统的线程实现确保了每个线程ID系统范围内的唯一性，线程不复存在后其线程ID会被复用  

### 线程的控制
* 创建线程： pthread_create
* 终止线程： pthread_cancle，取消给定的线程ID的线程。默认情况下目标线程只有在执行到某个取消点才会响应该请求
* 连接已终止的线程： pthread_join，该函数一直等待由线程ID指定的线程终止，如果目标线程已经处于终止状态，函数立即返回。当目标线程交出控制权后，调用线程会接过流程控制权并继续执行pthread_join函数调用之后的代码，相当于`“连接”`。事实上，如果一个线程可以被连接，那么在它终止之前必须被连接，否则就会变成一个`僵尸线程`，僵尸线程会导致系统资源浪费也会无意义减少所在进程可创建线程的数量。
* 分离线程：pthread_detach，将一个线程分离意味着它不再是一个可连接的线程，分离操作的另一个作用是让操作系统内核在目标线程终止时自动进行清理和销毁工作。分离操作是`不可逆`的，无法使一个`不可连接`的线程变回到`可连接`的状态。对于一个已经处于分离状态的线程，执行终止操作仍然有效。

![Linux内核线程状态转换](https://raw.githubusercontent.com/Juntaran/Note/master/pictures/Linux内核线程状态转换.jpg)


### 线程的同步

1.  互斥量：在同一时刻只允许一个线程处于临界区之内的约束称为`互斥mutex`，  
每个线程在进入临界区之前，都必须先锁定某个对象，  
成功锁定对象的线程才会允许进入临界区，否则会阻塞，  
这个对象成为互斥对象或互斥量。  
互斥量有两种可能的状态：`已锁定状态`和`未锁定状态`。互斥量不允许`二次加锁`

2.  条件变量：与互斥量不同，条件变量的作用并不是保证同一时刻仅有一个线程访问某一个共享数据，  
而是在对应的共享数据的状态发生变化时，通知其他因此被阻塞的线程  
条件变量的操作有三种：
2.1 等待通知(wait)：阻塞当前线程，直到收到该条件变量发来的通知
2.2 单发通知(signal)：让条件变量向`至少一个`正在等待它通知的线程发送通知，以表示某个共享数据的状态已经变化，这里的signal与进程间通信的信号signal不同
2.3 广播通知(broadcast)：让条件变量给正在等待它通知的`所有线程`发送通知，以表示某个共享数据的状态已经改变


### 线程安全性

如果有一个代码块，可以被多个线程并发执行，且总能产生预期的结果，那么该代码块就是`线程安全`的  
让函数具有线程安全性的最有效方式就是使其`可重入(reentrant)`  
如果某个进程中的所有线程都可以并发地对一个函数进行调用，并且无论它们调用该函数的实际执行情况怎样，  
该函数都可以产生预期的结果，那么这个函数是`可重入`的  
如果多个线程并发地调用该函数，与它们以任意顺序依次调用它所产生的效果总是`相同`的，  
那么该函数就是一个`可重入`函数


# 并发编程的建议

* 控制临界区的纯度：临界区应仅包含操作共享数据的代码  
* 控制临界区的粒度：如果没有长耗时的无关代码，就把它们合并在一起；反之，放弃合并  
* 减少临界区中代码的执行耗时：注意死锁
* 避免长时间持有互斥量：减少临界区中代码执行耗时、使用条件变量
* 优先使用原子操作而不是互斥量：如果数据结构`非常简单`（比如数值类型），建议使用原子操作；对于结构稍微复杂一些的共享数据，原子操作则无能为力





___
Reference:
* [Go并发编程实战](http://www.ituring.com.cn/book/1950)




